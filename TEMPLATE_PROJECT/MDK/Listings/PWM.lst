C251 COMPILER V5.60.0,  PWM                                                                10/01/22  22:23:44  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN ..\Output\PWM.obj
COMPILER INVOKED BY: F:\ProgramData\keil5\C251\BIN\C251.EXE ..\CODES\BOARD\PWM.c LARGE INTR2 BROWSE INCDIR(..\CODES\BOAR
                    -D;..\CODES\ALGORITHM;..\CODES\DRIVER;..\CODES\USERS) DEBUG PRINT(.\Listings\PWM.lst) OBJECT(..\Output\PWM.obj) 

stmt  level    source

    1          /*
    2           * @Description  : PWM输出的具体实现
    3           * @Author       : FZU Liao
    4           * @Date         : 2021-12-31 19:34:13
    5           * @LastEditors  : Liao
    6           * @LastEditTime : 2022-01-10 09:26:07
    7           * @FilePath     : \TEMPLATE_PROJECT\CODES\BOARD\PWM.c
    8           * Copyright 2021 FZU Liao, All Rights Reserved. 
    9           */
   10          
   11          #include "PWM.h"
   12          
   13          const uint32 PWM_CCMR_ADDR[] = {0x7efec8, 0x7efec9, 0x7efeca ,0x7efecb,
   14                                          0x7efee8, 0x7efee9, 0x7efeea, 0x7efeeb};
   15          const uint32  PWM_CCR_ADDR[] = {0x7efed5, 0x7efed7, 0x7efed9, 0x7efedb,
   16                                                                      0x7efef5, 0x7efef7, 0x7efef9, 0x7efefb};
   17          const uint32 PWM_CCER_ADDR[] = {0x7efecc, 0x7efecd, 0x7efeec ,0x7efeed};
   18          const uint32  PWM_ARR_ADDR[] = {0x7efed2,0x7efef2};
   19          
   20          void PWM_INIT_PWMCHANNEL(PWM_CHANNEL_enum PWMn_CHx_Pin,uint32 Frequecy, uint16 Duty){
   21   1              uint16 DUTY_RATIO;              //占空比
   22   1              uint16 CYCLE_TIME;              //周期
   23   1              uint16 FREQUENCY_DIVIDER = 0;   //分频
   24   1      
   25   1              if(Duty>10000) Duty = 10000;    //限幅
   26   1          P_SW2 |= 0x80;
   27   1      
   28   1              if(Frequecy>500){
   29   2                      FREQUENCY_DIVIDER = (SYS_CLK / Frequecy) >> 16;
   30   2                      CYCLE_TIME = SYS_CLK / Frequecy;                        
   31   2                      CYCLE_TIME = CYCLE_TIME / (FREQUENCY_DIVIDER + 1) - 1;
   32   2              }else{
   33   2                      FREQUENCY_DIVIDER = (SYS_CLK/Frequecy/PWM_MAX_DUTY) - 1;
   34   2                      CYCLE_TIME = PWM_MAX_DUTY;                      
   35   2              }
   36   1      
   37   1              DUTY_RATIO = CYCLE_TIME * ((float)Duty/PWM_MAX_DUTY);
   38   1          //PWMB配置
   39   1              if(PWMB_CH1_P20 <= PWMn_CHx_Pin){
   40   2                      PWM2_ENO |= (1 << ((2 * ((PWMn_CHx_Pin >> 4) - 4))));
   41   2                      PWM2_PS |= ((PWMn_CHx_Pin & 0x03) << ((2 * ((PWMn_CHx_Pin >> 4) - 4))));
   42   2      
   43   2                      (*(unsigned char volatile far*)(PWM_CCER_ADDR[PWMn_CHx_Pin>>5]))|=(uint8)(1<<(((PWMn_CHx_Pin>>4)&0x01)*
             -4));
   44   2      
   45   2                      PWM2_PSCRH = (uint8)(FREQUENCY_DIVIDER>>8);
   46   2                      PWM2_PSCRL = (uint8)FREQUENCY_DIVIDER;
   47   2      
   48   2              }
   49   1          //PWMA配置
   50   1              else{
   51   2                      PWM1_ENO |= (1 << (PWMn_CHx_Pin & 0x01)) << ((PWMn_CHx_Pin >> 4) * 2);  
   52   2                      PWM1_PS  |= ((PWMn_CHx_Pin & 0x07) >> 1) << ((PWMn_CHx_Pin >> 4) * 2); 
   53   2                      (*(unsigned char volatile far *) (PWM_CCER_ADDR[PWMn_CHx_Pin>>5])) 
   54   2                              |= (1 << ((PWMn_CHx_Pin & 0x01) * 2 + ((PWMn_CHx_Pin >> 4) & 0x01) * 0x04));
   55   2                      PWM1_PSCRH = (uint8)(FREQUENCY_DIVIDER>>8);
   56   2                      PWM1_PSCRL = (uint8)FREQUENCY_DIVIDER;
   57   2              }
C251 COMPILER V5.60.0,  PWM                                                                10/01/22  22:23:44  PAGE 2   

   58   1              
   59   1              (*(unsigned char volatile far *) (PWM_ARR_ADDR[PWMn_CHx_Pin>>6]))       = (uint8)(CYCLE_TIME>>8);
   60   1              (*(unsigned char volatile far *) (PWM_ARR_ADDR[PWMn_CHx_Pin>>6] + 1))   = (uint8)CYCLE_TIME;
   61   1      
   62   1              (*(unsigned char volatile far *) (PWM_CCR_ADDR[PWMn_CHx_Pin>>4]))               = DUTY_RATIO>>8;
   63   1              (*(unsigned char volatile far *) (PWM_CCR_ADDR[PWMn_CHx_Pin>>4] + 1))  = (uint8)DUTY_RATIO;
   64   1              
   65   1              (*(unsigned char volatile far *) (PWM_CCMR_ADDR[PWMn_CHx_Pin>>4])) |= 0x06<<4;
   66   1              (*(unsigned char volatile far *) (PWM_CCMR_ADDR[PWMn_CHx_Pin>>4])) |= 1<<3;
   67   1      }
   68          
   69          void PWM_SET_DUTY(PWM_CHANNEL_enum PWMn_CHx_Pin,uint16 Duty){
   70   1          uint16 DUTY_RATIO;
   71   1              uint16 ARR = ((*(unsigned char volatile far *) (PWM_ARR_ADDR[PWMn_CHx_Pin>>6]))<<8) 
   72   1                       |(*(unsigned char volatile far *) (PWM_ARR_ADDR[PWMn_CHx_Pin>>6] + 1 ));
   73   1              if(Duty>10000) Duty=10000;
   74   1              DUTY_RATIO = ARR * ((float)Duty/PWM_MAX_DUTY);
   75   1              (*(unsigned char volatile far *) (PWM_CCR_ADDR[PWMn_CHx_Pin>>4]))         = DUTY_RATIO>>8;      
   76   1              (*(unsigned char volatile far *) (PWM_CCR_ADDR[PWMn_CHx_Pin>>4] + 1)) = (uint8)DUTY_RATIO;
   77   1              PWM_ENABLE(PWMn_CHx_Pin);
   78   1      }
   79          
   80          
   81          void PWM_ENABLE(PWM_CHANNEL_enum PWMn_CHx_Pin){
   82   1          if(PWMB_CH1_P20 <= PWMn_CHx_Pin){
   83   2              PWM2_BKR |= 0x80;
   84   2              PWM2_CR1 |= 0x01;
   85   2          }else{
   86   2              PWM1_BKR |= 0x80;
   87   2              PWM1_CR1 |= 0x01;
   88   2          }
   89   1      }
   90          
   91          void PWM_DISABLE(PWM_CHANNEL_enum PWMn_CHx_Pin){
   92   1          if(PWMB_CH1_P20 <= PWMn_CHx_Pin){
   93   2              PWM2_BKR &= 0x7F;
   94   2              PWM2_CR1 &= 0xFE;
   95   2          }else{
   96   2              PWM1_BKR &= 0x7F;
   97   2              PWM1_CR1 &= 0xFE;
   98   2          }
   99   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1072     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        88     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
